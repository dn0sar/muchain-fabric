package protos

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"bytes"
)

// IsValidBlockExtension checks whether the other txSetStateValue is a valid extension of this txSetStateValue blockwise
// meaning it only adds new blocks or nothing, and the txNumber is consistent with the total number of transactions
// declared
func (txSetStateValue *TxSetStateValue) IsValidBlockExtension(other *TxSetStateValue) error {
	if txSetStateValue.TxNumber > other.TxNumber {
		return fmt.Errorf("The next state for this transactions set contains less transactions. "+
			"Number of transactions info at current state: %d; other state: %d", txSetStateValue.TxNumber, other.TxNumber)
	}
	for block, txs := range txSetStateValue.TxsInBlock {
		otherTxs, ok := other.TxsInBlock[block]
		if !ok {
			return fmt.Errorf("The next state for this transactions set does not have transaction info for block %d.", block)
		}
		if otherTxs != txs {
			return fmt.Errorf("The next state for this transactions set contains conflicting "+
				"info about the transactions at block %d. Current: %d, Next: %d", block, txs, otherTxs)
		}
	}
	otherTotTxs := uint64(0)
	for _, txs := range other.TxsInBlock {
		otherTotTxs += txs
	}
	if other.TxNumber != otherTotTxs {
		return fmt.Errorf("Number of transactions declared in the next state is not consistent with the " +
			" information declared in the next state block info.")
	}
	return nil
}

// IsIndexInRange returns an error if the index of this txSetStateValue does not point to a transaction of its tx set
func (txSetStateValue *TxSetStateValue) IsIndexInRange() error {
	txs, ok := txSetStateValue.TxsInBlock[txSetStateValue.Index.BlockNr]
	if !ok {
		return fmt.Errorf("Transaction indexed in a block that does not contain transactions for this set")
	}
	if txSetStateValue.Index.InBlockIndex >= txs {
		return fmt.Errorf("Transaction indexed by the state is out of range.")
	}
	return nil
}

// Bytes returns this block as an array of bytes.
func (txStateValue *TxSetStateValue) Bytes() ([]byte, error) {
	data, err := proto.Marshal(txStateValue)
	if err != nil {
		return nil, fmt.Errorf("Could not marshal txSetStateValue: %s", err)
	}
	return data, nil
}

func (txSetStVal *TxSetStateValue) ToString() string {
	var buffer bytes.Buffer
	buffer.WriteString(fmt.Sprintln("Nonce:", txSetStVal.Nonce))
	buffer.WriteString(fmt.Sprintln("Introduced at block number:", txSetStVal.IntroBlock))
	buffer.WriteString(fmt.Sprintln("Last modified at block number:", txSetStVal.LastModifiedAtBlock))
	buffer.WriteString(fmt.Sprint("Active transaction index: {Block: ",  txSetStVal.Index.BlockNr, " - Index in block: ", txSetStVal.Index.InBlockIndex, "}\n"))
	buffer.WriteString(fmt.Sprintln("Number of transactions in the set:", txSetStVal.TxNumber))
	buffer.WriteString(fmt.Sprintln("Number of transactions belonging to this set at a given block:"))
	buffer.WriteString(fmt.Sprintln("Block\t\t\tTransactions"))
	for k, v := range txSetStVal.TxsInBlock {
		buffer.WriteString(fmt.Sprint(k, "\t\t\t", v, "\n"))
	}
	return buffer.String()
}

// UnmarshalTxSetStateValue converts a byte array generated by Bytes() back to a block.
func UnmarshalTxSetStateValue(marshalledState []byte) (*TxSetStateValue, error) {
	stateValue := &TxSetStateValue{}
	err := proto.Unmarshal(marshalledState, stateValue)
	if err != nil {
		return nil, fmt.Errorf("Could not unmarshal txSetStateValue: %s", err)
	}
	return stateValue, nil
}
